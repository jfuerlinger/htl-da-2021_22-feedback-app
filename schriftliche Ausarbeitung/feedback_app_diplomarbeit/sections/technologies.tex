\section{.NET 6}
\setauthor{Stefano Pyringer}
Das .NET wird für die Entwicklung und Ausführung von Anwendungsprogrammen verwendet und ist Teil der .NET-Plattform.
Sie ist mit einer MIT-Lizenz lizensiert und ist somit eine freie open-source Software. Das .NET-Framework wurde von Microsoft 
2016 unter den Namen .NET Core modernisiert. .NET ist der Nachfolger von .NET Core seit Dezember 2020 und ist in der Version 6.0.7 verfügbar (Stand Juli 2022).

\subsection{Allgemeine Eigenschaften}
Microsoft die Konzeptideen von Java, aufgrund des hohen Erfolgs der Sprache,
übernommen und versucht, die bekannten Schwachstellen der Sprache auszumerzen und dadurch die Messlatte mit 
.NET spürbar höher gelegt.

% ev. Bilder einfügen
Folgenede Eigenschaften bringt .NET mit sich:

\subsubsection{Objektorientierung}
.NET ist komplett objektbasiert. Auch einfache Datentypen wie Integer werden als Objekte behandelt.

\subsubsection{WinAPI-32-Ersatz}
Microsoft will langfristig die Win32-API durch Klassen des .NET-Frameworks ersetzten. Alle Sprachen greifen 
daher auf die gleiche Bibliothek zurück. Dadurch verwischen die charackterischtischen Merkmale der verschiedenen Sprachen. 
Die Wahl einer Sprache im .NET ist nicht mehr mit den Entscheidungen gleichzusetzen, wie effizient eine Anwendung geschrieben werden kann 
oder was sie zu leisten imstande ist.

\subsubsection{Platttformunabhängigkeit}
Auf .NET bassierenden Anwendungen laufen in einer Umgebung, die mit der virtuellen Maschine von Java verglichen werden kann.
Erst zur Laufzeit der Anwendung wird der Maschinencode generiert. Aufgrund der öffentlichen Dokumentation der Spezifikation von 
der Common Language Runtime (CLR) lässt sich sie sich auf Plattformen portieren wie Unix oder Linux. 
Quelloffene Beispiele sind Mono oder CoreCLR.

\subsection{Sprachunabhängigkeit}
Eine in C\# geschriebene Klasse kann aus jeder anderen .NET-kompitablen Sprache wie F\# aufgerufen werden, ohne die Verwendung über eine 
spezifizierte Schnittstellentechnologie wie COM/COM+ gehen zu müssen. Beispielweise lässt sich eine C\# implementierte Klasse aus einer 
VB.NET-KLasse ableiten und auch umgekehrt ist dies möglich.

\subsection{Architektur und Anwedungsgebiete}
Das Software-Development-Kit (SDK) unterstützt Windows (ab 7, 32/64 Bit und Arm), macOS (ab 10.12), Linux-Distrubtionen(64 Bit, Arm) 
und für Docker oder Snappy existieren offizelle Images. .NET besteht aus 2 Hauptkomponenten CoreCLR und CoreFX. 
Sie sind vergleichbar mit der Common Language Runtime (CLR) und der  Framework Class Library (FCL) 
von .NET Framework's Common Language Infrastructure (CLI). .NET unterstüzt 

Folgende Entwicklungsumgebungen werden von der SDK unterstützt:
\begin{itemize}
    \item Visual Studio (ab 2022 auch für macOS)
    \item Visual Studio Code
    \item per Kommandozeile mit dem .NET SDK
    \item JetBrains Rider 
\end{itemize}

Standardmäßig können für die Entwicklung von .NET Apps die Programmiersprachen C\#, F\# oder Visual Basic verwendet werden. 
.NET kann in der Funktionalität mithilfe von NuGet-Packages erweitert werden. Folgende Anwendungsgebiete unterstützt .NET 6:
\begin{itemize}
    \item Web-Apps und Micro-Services (ASP.NET Core)
    \item Kommandozeilen Programme
    \item Klassenbibliotheken
    \item GUI-Applikationen für Windows (UWP, WPF) und Cross-Plattform-Apps (.NET MAUI, Xamarin)
    \item Machine Learning (ML.NET, Apache Spark for .NET)
    \item Game Development (Unity, Cryengine, MonoGame, etc.)
    \item Internet of Things
\end{itemize}

\section{ASP.NET Core}
\setauthor{Stefano Pyringer}
ASP.NET Core ist ein modulares Open-Source Web-Framework für die Entwicklung von modernen Web-Anwendungen.
Es wurde von Microsoft entwickelt und ist der Nachfolger von ASP.NET seit .NET 5. Das Web-Framework ist ein Bestandteil von 
.NET. ASP.NET Core wurde von Grund auf neu entwickelt und unterscheidet sich wesentlich von Vorgänger Versionen. 

Die wichtigsten Vorteile zu ASP.NET sind:
\begin{itemize}
    \item Entwicklung von Web-UI und Web-APIs in einer einheitlichen Umgebung
    \item Open-Source und Community freundlich
    \item Plattformunabhängigkeit (Windows, MacOS, Linux)
    \item Moderne Entwicklungstools
    \item Leichtgewichtige, modulare und leistungsstarke HTTP-Request Pipeline
    \item Umfassende Testmöglichkeiten
    \item Dependency Injection
    \item Razor Pages und Blazor ermöglichen dynamische Webseiten mit .NET Programmiersprachen
    \item Cloud kompitabel
    \item Mehrere Hosting Möglichkeiten:
    \begin{itemize}
        \item Kestrel
        \item IIS
        \item HTTP.sys
        \item Nginx
        \item Apache
        \item Docker
    \end{itemize}
\end{itemize}

\subsection{Anwendungsgebiete}
\setauthor{Stefano Pyringer}

\subsubsection{Interaktive clientseitige Web-Apps mit Blazor/Razor View Engine}
Mithilfe von Blazor ist das Erstellen von clientseitigen Webbenutzeroberflächen möglich.
Zudem bietet die Razor View Engine die Möglichkeit, .NET-Sprachblöcke in HTML-Seiten einzubetten.
Die UI wird anschließend als HTML und CSS gerendert inklusive umfassender Browserunterstützung (auch mobile Browser).
Mit der Technik des Client-Side-Renderings werden die Skripte im Browser ausgeführt und verarbeitet.

\subsubsection{Web-APIs}
Mit ASP.NET Core können RESTful-basierte Webservices (HTTP-API) entwickelt werden. Die Services werden von Controllern gesteuert und diese 
unterstützen CRUD-Datenoperationen (Create, Read, Update, Delete).
Die Schnittstellen können mit Swagger/Open-API dokumentiert werden.

\subsubsection{Web-Apps und APIs mit MVC}
ASP.NET Core MVC ist ein zusätzliches umfassendes Framework bassierend auf dem Model-View-Controller-Entwursfmusters. Damit werden 
die einzelnen Bereiche getrennt, was die Entwicklung, Organisition und Testbarkeit erleichtert. 
ASP.NET Core MVC wird parallel zu Razor Pages als Alternative weiterhin unterstützt.

\subsubsection{Web-Apps und APIs mit Razor Pages}
Razor Pages ist der Nachfolger von MVC in ASP.NET Core und ersetzt ASP.NET Web Forms. 
Sie bassiert auf dem MVC-Framework, jedoch ist die Komplexität reduziert. Razor Pages verwendet das 
MVVM-Entwurfsmuster (Model-View-View-Model). Somit entfällt der Controller.


\subsubsection{Echtzeit-Web-Apps mithilfe von SignalR}
SignalR ist eine Open-Source-Bibliothek mithilfe die Hinzuufügung von Echtzeitwebfunktionen zu Apps zu vereinfachen.
Diese Funktionen ermöglichen serverseitigen Code, Inhalte sofort an die Clients zu senden. SignalR verarbeitet die Verbindungsveraltung 
automatisch.

SignalR ist besonders für Szenarien geeignet, wo man Daten vom Server mit einer hohen Aktualisierungsfrequenz benötigt. 
Solche Kanditen können sein:
\begin{itemize}
    \item Dashboard oder Überwachungsdienste wie Sofortupdates wie Reisehinweise oder Börsenwerte.
    \item Soziale Netzwerke-Apps mit Chatroom-Funktion
    \item Applikationen, die wiederholt in kürzester Zeit Daten benötigen (z. B.Gaming, GPS, Voting, Auktionen, etc.)
\end{itemize}

\subsubsection{gRPC-Dienste}
RPC steht für Remote Procedure Call und eignet sich dafür, Mikroservices miteinander kommunizieren zu lassen.
Das dRPC-Framwork ist sprachunabhängig und hochleistungsfähig.

Es eignet sich besonders für folgende Szenarien:
\begin{itemize}
    \item Simple Mikroservices, wo Effizienz wichtig ist
    \item Mehrsprachige Systeme
    \item Point-to-Point-Dienste, die in Echtzeit Streaminganforderungen oder -antworten verarbeiten müssen.
\end{itemize}

\subsubsection{Datengesteuerte Web-Apps}
Erstellung von Web-Applikationen, die mit Datenbankensysteme zusammenarbeiten. Daten können im 
Browser mittels CRUD-Operationen verändert werden, ohne auf eine spezielle Software, wie den Oracle SQL-Explorer, zuzugreifen.

\subsubsection{Hybrid-App Development}
Verschiedene Technologien können miteinander kombiniert werden. So können alle vorherigen genannten Anwendungsmöglichkeiten 
mit ASP.NET Core in einer App verwendet werden. 
Es ist auch ein ist auch eine Verschmelzung von Benutzeroberflächen mit .NET MAUI, WPF und Windows Forms möglich. Diese laufen nicht im Browser, 
sondern in einer eigenen Anwendung dargestellt, ohne die z. B. exestierende Oberfläche neu für die anzuwendende UI zu programmieren.

\subsection{Identity}
\setauthor{Stefano Pyringer}
ASP.NET Core Identity ist eine API, dass das Benutzermanagement (Login-Interface) ermöglicht. 
Die Benutzer können einen Account erstellen und mit diesen einloggen. Die API verwendet dafür eine 
SQL-Datenbank, die die Benutzernamen, Rollen, Passwörter, E-Mail Adressen und weitere benutzerbezogene Daten verwaltet. 
Als Alternative ist die Speicherung der Datenbank auf externen Datenbanksystemen wie Azure möglich.

Ein externer Login von Login-Providern wie Google, Microsoft, Twitter und Facebook wird von ASP.NET Core Identity ebenfalls unterstützt.
Der Identity Source Code ist auf Github erhältlich.

Eine erweiterte Version von ASP.NET Core Identity ist IdentityServer4, welche ein OpenID Connect und OAuth 2.0 Framework bietet.
Zudem sind folgende erweiterte Sicherheitsfeatures möglich:

\begin{itemize}
    \item Authentication as a Service (AaaS)
    \item Single sign-on/off (SSO) Zugangsverfahren für Multi-Anwendungsszenarien
    \item Zugriffskontrolle für APIs
    \item Federation Gateway
\end{itemize}

\section{Entity Framework Core}
\setauthor{Stefano Pyringer}
\subsection{Überblick}

Das Entity Framework (EF) ist ein moderner Objektdatenbank-Mapper für .NET-Objektstrukturen. Es
wurde von Microsoft entwickelt und die erste Version erschien als Teil des .NET Framework 3.5 im
Jahr 2008. Damals gehörte es noch zu ADO.NET, welches seit 2002 exestiert.  Es ist als Ergänzung zu verstehen, 
der die Differenzen zwischen der objektorientierten Programmierung und relationalen Datenbanken addressiert.

Im Jahr 2021 mit der Version 5 machte Microsoft das Framework quelloffen verfügbar und hieß
Entity Framework. Mit .NET Core gibt es seit 2016 das Framework als separates Zusatzpaket Entity
Framework Core (EF Core). Die aktuellste Version ist EF Core 6.0 (Stand Juli 2022) und 
erhält Langzeit-Support (LTS) bis 8. November 2024.

Es unterstützt LINQ-Abfragen, Migrationen und Änderungsnachverfolgung (Tracking). EF-Core
unterstützt viele Datenbanken wie SQL-Datenbanken (lokal und Azure), SQLite, MySQL, PostgreSQL
und Azure Cosmos DB.

\subsection{Überblick ORM}
Objektrelationale Abbildung (engl. Object-realtional mapping) kann mit einer objektorientieren
Programmiersprache Objekte (Klassen) in einer relationalen Datenbank abgelegt werden. ORM ist
somit eine Lösung für die Kommunikation zwischen Objektcode und relationaler Datenbank.

Zu den Vorteilen von ORM zählen neben der Datenzugriffstechnik auch:

\begin{itemize}
    \item Vereinfachte Entwicklung, da die Konvertierung von Objekt und Tabelle und umgekehrt
    automatisiert wird, was zu geringeren Entwicklungs- und Wartungskosten führt.
    \item Weniger Code im Vergleich zu Embedded SQL und handgeschriebenen gespeicherten
    Prozeduren
    \item Transparente Objektzwischenspeicherung in der Anwendungsebene zur Verbesserung der
    Systemleistung
    \item Einfache und schnelle Wartung der Anwendung
\end{itemize}

Diese Technik bringt auch Nachteile mit sich:

\begin{itemize}
    \item Langsamere Performance im Gegensatz zu gespeicherten Prozeduren
    \item ORM-Abhängigkeit kann unter bestimmten Umständen zu schlecht gestalteten
    Datenbanken führen
\end{itemize}

\subsection{Architektur}

\begin{figure}[h]
    \begin{center}
        \includegraphics*[width=16cm]{pics/ADO_NET_EF.png}
        \caption[Prinzipielle Funktionsweise des ADO.NET Entity Framework]{Prinzipielle Funktionsweise des ADO.NET Entity Framework \cite{ArchitekturEF}}
    \end{center}
\end{figure}

\subsection{Überblick wichtiger EF-Objekte}
\subsubsection{DbContext}
Stellt eine Verbindung mit der Datenbank dar. Stellt Methoden für Abfragen (Query),
Änderungsverfolgung (Tracking) und Speichern (Save) bereit.

\subsubsection{DbQuery}
Stellt Methoden für das Hinzufügen (Add), Anhängen (Attach) und Entfernen (Remove) von
Entitäten bereit.

\subsubsection{DbSet}
Erbt von DbQuery und stellt die entsprechenden Methoden für Entity-Typen bereit.

\subsubsection{Change Tracker API}
Bietet Methoden an, um Änderungen verfolgen zu können.

\subsubsection{Validation API}
Führt eine automatische Validierung der Daten im DataLayer durch.

\subsubsection{Code First Model Building}
Erstellt eine Datenbank mithilfe von Code-basierten Klassen

\subsection{EF-Modellieransätze}
Für das Entity Framework gibt es 2 Modellieransätze, nämlich Code First und Model First. Ersteres setzt auf die Erzeugung einer 
Datenbankstruktur mit C\# Code. Model First verwendet im Gegensatz Designer und Assistenten für die Erstellung der Datenbankstruktur.

Daraus ergeben sich folgende Szenarien:

\subsubsection{Code First - keine Datenbank vorhanden}
Bestehende Klassen (MVC-Model) werden mit Annotationen ausgezeichnet, welche die Abbildung auf eine Datenbank steuern.
Darauf afbauend werden vom DbContext die Datenbank und die Datenbank-Tabellen modelliert und beim Aufruf der SaveChanges-Methode erstellt.

\subsubsection{Model First - keine Datenbank vorhanden}
Die Entity-Klassen werden mit einem grafischen Designer modelliert. Dieses Modell wird mit Hilfe des Text Template Transformation Toolkit (T4) und 
der dazugehörigen Skriptsprache in Entity-Klassen umgewandel. Der Designer erstellt zusätzlich ein SQL-Skript, mit dem die Datenbank erstellt wird.

\subsubsection{Code First - Verwendung einer bestehenden Datenbank}
Die Entity-Klassen können entsprechend der vorgegebenen Datenbank manuell erstellt werden. Dies ist jedoch sehr arbeitsintensiv.

\subsubsection{Model First - Verwendung einer bestehenden Datenbank}
Mit Hilfe eines Assistenten wird die Datenbank abgefragt und entsprechend der Datenbankstruktur ein passendes Modell erstellt.
Dieses wird mit einem T4-Script in die entsprechenden Klassen umgewandelt.

\subsection{Validierungsmöglichkeiten}
Das Entity Framework bietet eine Vielzahl von Validierungsfeatures. Dieses Konzept gilt für mehrere
Ebenen:

\begin{itemize}
    \item Entity direkt → Domainspezifisch
    \item Persistenzschicht → Datenbankabhängig
    \item Web-Ui clientseitig → Validierung im Browser
    \item WPF → Validierung am Desktop
\end{itemize}

Die Validierungen können unterschiedlich implementiert werden:

\subsubsection{Feld-Ebene}
Es werden Data-Annotationen in den Model-Felder verwendet. Diese sind in EF Core schon vorgefertigt. Es können aber auch eigene
Annotationen(-klassen) erstellt werden (Custom Validation).

\subsubsection{Objekt-Ebene}
Sie wird empfohlen, wenn die Validierung nicht genau einem Feld zugeordnet werden kann.
Es wird die Methode Validate benutzt, wenn Entity IValidatableObject implementiert wird. Es können
mehrere Validierungsfehler definiert werden.

\subsubsection{Context-Ebene}
Sie ist objektübergreifend (mehrere Objekte) und benutzt die Validation unter Verwendung
der Daten aus der Datenbank.
Es wird verwendet, wenn eine Validation unter Berücksichtigung mehrerer oder aller Objekte
notwendig ist (z. B. Unique-Constraint).

\subsection{MSSQLLocalDB}
\setauthor{Stefano Pyringer}


\section{OpenAPI und Swagger}
\setauthor{Stefano Pyringer}
Die OpenAPI Spezifikation, auch als Swagger-Spezifikation bekannt, ist ein Standard für die Beschreibung von 
REST-Schnittstellen. Es war ursprünglich ein Bestandteil des Open-Source-Frameworks Swagger, welches HTTP-Webservices bereitstellt.
Seit 2016 ist es ein eigenständiges Projekt, das von der OpenAPI Initiative verwaltet und gefördert wird. 
Mitlgieder dieser Initiative sind große Unternehmen wie z. B. Microsoft, Google, IBM, Paypal und SAP sowie weitere Initiative wie Smartbear und die Linux Foundation.
Ziel ist es, ein offenes und herstellerneutrales Beschreibungsformat für API-Dienste bereitzustellen. Bei den API-Spezifikationen kommen meistens die 2 Sprachen YAML oder JSON zum Einsatz. 
Die aktuellste der OpenApi-Spezifikation ist 3.1 (Stand Juli 2022). 

Der OpenApi-Standard definiert eine Reihe von Eigenschaften, die auch als sogennante Objekte zusammengefasst werden können. 
Folgende Objekte liegen in einer Dokumentation vor:
\begin{itemize}
    \item Info Objekt: Version und Name der API
    \item Contact Info: Kontaktinformationen des API-Anbieters
    \item License Object: Unter welcher Lizenz die API lizensiert ist
    \item Server Object: Hostnamen, URL-Struktur und Ports der Server
    \item Components Object: gekapselte Objekte, die sich in einer API-Definition mehrfach verwenden lassen
    \item Paths Objects: relative Pfade zu Endpunkte der API, die mit dem Server Object gemeinsam genutzt werden
    \item Path Item Object: für einen spezifischen Pfad wie GET, PUT, POST, DELETE, etc.
    \item Operation Object: legt unter anderem die Parameter und die zu erwartenden Server-Responses für eine Operation fest
\end{itemize}

Da es um eine nur um eine technische Spezifikation handelt, ist es nicht an eine spezielle technische Implementierung gebunden. Dafür gibt es Tools wie Swagger. 
Swagger ist ein Sammlung von Open-Source-Werkzeugen, die helfen, die API-Dokumention zu entwickeln. 
\begin{itemize}
    \item Swagger Editor: ein Browser-basierter Editor, wo die OpenAPI-Dokumentation geschrieben werden kann
    \item Swagger UI: erzeugt die OpenAPI-Dokumentation
    \item Swagger Codegen: generiert die Server Stubs und Client SDKs
\end{itemize}

Es exestieren auch kostenplichtige Tools wie SwaggerHub Enterprise, Swagger Inspector und API-Tree. 
Desweiteren gibt es verschiedene Entwicklungsumgebungen und Erweiterungen zur Unterstützung der OpenAPI-Dokumentation. 
Nicht jede beliebige API lässt sich mittels OpenAPI abbilden. REST-APIs werden vollständig unterstützt.

\subsection{Anwendungsgebiete}
Generell wird die OpenAPI eingesetzt, um REST-APIs auf eine einheitliche Weise zu beschreiben. Da diese Definition in einem 
maschinenlesbaren Format vorliegen, können automatisiert folgende Möglichkeiten erzeugt werden.

\subsubsection{Erzeugung der API-Dokumentation}
Es kann aus den Code der API-Definition eine HTML-basierte Dokumentation erzeugt werden. Diese dient als Nachschlagewerk für jene Entwickler, 
die auf die APIs zugreifen wollen. Ändert sich die API-Defintion, so wird die Dokumentation automatisch neu erzeugt.

\subsubsection{Erzeugung von Anbindungen in verschiedenen Programmiersprachen}
Aus API-Definition können mit den passenden Tools eine Client-seitige Softwarebibliothek in einer unterstützten Programmiersprache 
erzeugt werden. Diese werden ganz normal eingebunden und die Zugriffe auf die API-Diensten erfolgen z. B. über Funktionsaufrufe innerhalb 
der gewohnten Entwicklungsumgebung. Damit werden Entwickler mit unterschiedlichen Programmiersprachen der Zugriff auf die API ermöglicht.

\subsubsection{Erzeugung von Testfällen}
Aus den API-Defintion hat man die Möglichkeit, Testfälle zu definieren. Diese Test werden bei jeder Änderung der API automatisch durchgeführt, 
um sicherzustellen, dass jede Komponente der Software ordnungsgemäß funktioniert.

\subsection{Vorteile von OpenAPI}
Die Entwicklung und Pflege einer API wird in Einklang gehalten. Sie erlaubt es, dass die Koordination der API-Entwicklung zwischen Backend und 
Frontend verbessert wird. Beide Seiten können aus der API-Definition Code-Komponenten erzeugen lassen, so dass entwickelt und getestet werden kann, 
ohne auf die jeweils andere Seite warten zu müssen. Zudem ist es eine standardisierte Basis für die Entwicklung und Dokumentation von APIs.

Außerdem ergeben sich aus der Nutzung von OpenAPI weitere Vorteile:
\begin{itemize}
    \item HTTP-APIs werden unabhängig von einer spezifischen Programmiersprache definiert
    \item Server-Code für eine OpenAPI definierte API generieren
    \item Client-Bibliotheken für eine OpenAPI-konforme API in mehr als 40 Programmiersprachen generieren
    \item OpenAPI-Defintionen mit geigneten Tools verarbeiten
    \item Eine interaktive API-Dokumentation erstellen
    \item Auf API-Services mit minimalen Implementationsaufwand zugreifen
    \item Services verstehen, ohne dafür Einsicht in den Quelltext oder weiteren zusätzlichen Dokumentation nehmen zu müssen
\end{itemize}

\section{JWT Token}
\setauthor{Stefano Pyringer}

\newpage

\section{Xamarin}
\setauthor{Mirzet Sakonjic}
\cite{XML}
\begin{figure}[h]
    \begin{center}
        \includegraphics*[width=9cm]{pics/Xamarin_logo.png}
        \caption[Xamarin Logo]{Xamarin Logo \cite{XMLlogo}}
    \end{center}
\end{figure}
\subsection*{Erklärung}
Im Jahr 2011 starteten die ehemaligen Mono-Entwickler das Unternehmen 
namens Xamarin, um auf dem aufkommenden Markt der mobilen Betriebssysteme 
eine plattformübergreifende Entwicklungsumgebung zu schaffen. 
Mono ist eine weitere, quelloffene Implementierung von Microsofts .NET Framework. 
Sie erlaubt die Änderung von plattformunabhängiger Software auf den Direktiven 
der Common Language Infrastructure und der Programmiersprache C\#.
Das gleichnamige, ein Jahr später vorgestellte Produkt ermöglichte den 
Einsatz der Programmiersprache C-Sharp zur Entwicklung von 
plattformübergreifenden Anwendungen für Windows, aber auch für MacOS. 
Ab der Version 2.0, die 2013 vorgestellt wurde, kamen als Zielplattformen 
die mobilen Betriebssysteme iOS und Android dazu, so dass nun aus Visual 
Studio heraus Programme für MacOS, iOS und Android entwickelt werden 
konnten. 
Xamarin ist eine Open-Source-Plattform zum Aufbau moderner 
und leistungsfähiger Applikationen für das Betriebssystem Apples (iOs), 
Android und Windows mit .NET. Xamarin ist eine Abstraktionsschicht, 
die die Verständigung von freigegebenem Code mit dem zugrunde liegenden 
Plattformcode verwaltet. Xamarin wird in einer verwalteten Umgebung 
ausgeführt, die Annehmlichkeiten wie Speicherzuweisung und Garbage 
Collection offeriert.
\subsection*{Funktionalität}
Xamarin realisiert es Entwicklern, durchschnittlich 90 Prozent ihrer App 
plattformübergreifend miteinander zu nutzen. Dieses Muster erlaubt es 
Entwicklern, ihre restlose Geschäftslogik in einer einzigen Sprache 
zu schreiben (oder vorhandenen Anwendungscode wiederzuverwenden), 
allerdings auf jedweder Plattform native Leistung, Look und Verhalten 
zu erzielen.
\subsection*{Begründung und Verwendung}
Xamarin ist für Entwickler mit den folgenden Zielen:
\begin{enumerate}
    \item Code, Test und Geschäftslogik plattformübergreifend teilen
    \item Plattformübergreifende Anwendungen in C\# mit Visual Studio schreiben
\end{enumerate}
Es wurde für unsere Arbeit ausgewählt, weil es den zusätzlichen Tools 
der Visual Studio-Software durchaus nahe kommt und zudem für uns kostenlos 
nutzbar ist. Die Enterprise-Lizenz wird von der HTL bereitgestellt und 
darf nur für schulische Zwecke verwendet werden.